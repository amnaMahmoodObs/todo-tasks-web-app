# Data Model: User Authentication

**Feature**: Authentication
**Date**: 2026-01-28
**Status**: Complete
**Purpose**: Define data structures and relationships for user authentication system

## Overview

The authentication feature requires two primary entities:
1. **User** - Represents user account data (managed by Better Auth)
2. **JWT Token** - Represents authenticated session (ephemeral, not stored in database)

This data model focuses on the database schema and in-memory token structure required for multi-user authentication.

---

## Entity 1: User

**Purpose**: Store user account information for authentication and identification.

**Ownership**: Better Auth manages the `users` table schema. Backend reads from this table for user data filtering but does not modify the schema.

**Storage**: Neon PostgreSQL `users` table

### Fields

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID (string) | PRIMARY KEY, NOT NULL | Unique identifier for user (generated by Better Auth) |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL, INDEX | User's email address for login |
| `password_hash` | VARCHAR(255) | NOT NULL | Bcrypt-hashed password (managed by Better Auth) |
| `name` | VARCHAR(255) | NULL | Optional display name for user |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp |

### Indexes

- **Primary Key**: `id` (UUID)
- **Unique Index**: `email` (for fast lookup during login)
- **Index**: `created_at` (for user analytics)

### Validation Rules

- **Email Format**: Must match regex `^[^\s@]+@[^\s@]+\.[^\s@]+$`
- **Email Uniqueness**: System MUST reject duplicate emails during signup
- **Password Length**: Minimum 8 characters (enforced by Better Auth)
- **Password Storage**: NEVER store plain-text passwords; only bcrypt hashes

### Relationships

- **One-to-Many with Tasks**: One user can have many tasks (defined in task CRUD feature)
  - Foreign key: `tasks.user_id` → `users.id`
  - Cascade behavior: TBD in task CRUD feature (likely SET NULL or CASCADE DELETE)

### Example Record

```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "email": "user@example.com",
  "password_hash": "$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy",
  "name": "John Doe",
  "created_at": "2026-01-28T10:30:00Z",
  "updated_at": "2026-01-28T10:30:00Z"
}
```

### SQLModel Definition (Backend)

```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional
import uuid

class User(SQLModel, table=True):
    """
    User account model (managed by Better Auth).

    This model is READ-ONLY from the backend perspective.
    Better Auth handles user creation, password hashing, and schema management.
    """
    __tablename__ = "users"

    id: str = Field(
        primary_key=True,
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique user identifier (UUID)"
    )
    email: str = Field(
        unique=True,
        index=True,
        max_length=255,
        description="User's email address for login"
    )
    password_hash: str = Field(
        max_length=255,
        description="Bcrypt-hashed password (managed by Better Auth)"
    )
    name: Optional[str] = Field(
        default=None,
        max_length=255,
        description="Optional display name"
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Account creation timestamp"
    )
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        sa_column_kwargs={"onupdate": datetime.utcnow},
        description="Last update timestamp"
    )
```

### TypeScript Interface (Frontend)

```typescript
// types/user.ts
export interface User {
  id: string;  // UUID
  email: string;
  name?: string | null;
  created_at: string;  // ISO 8601 timestamp
  updated_at: string;  // ISO 8601 timestamp
  // password_hash is NEVER exposed to frontend
}

export interface SignupRequest {
  email: string;
  password: string;
  name?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface AuthResponse {
  user: User;
  token: string;  // JWT token
  expires_at: string;  // ISO 8601 timestamp
}
```

---

## Entity 2: JWT Token

**Purpose**: Represent an authenticated session with cryptographically signed claims.

**Ownership**: Ephemeral - tokens are not stored in the database. Generated by Better Auth on login, verified by FastAPI middleware on each request.

**Storage**: Client-side (HTTP-only cookies or localStorage)

### Token Structure (JWT Payload)

| Claim | Type | Description |
|-------|------|-------------|
| `user_id` | string (UUID) | References `users.id` |
| `email` | string | User's email address |
| `iat` (issued at) | integer (Unix timestamp) | Token creation time |
| `exp` (expires) | integer (Unix timestamp) | Token expiration time (iat + 7 days) |
| `sub` (subject) | string | Subject identifier (user_id) |

### Token Format

```
Header.Payload.Signature

Example:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VyX2lkIjoiYTFiMmMzZDQtZTVmNi03ODkwLWFiY2QtZWYxMjM0NTY3ODkwIiwiZW1haWwiOiJ1c2VyQGV4YW1wbGUuY29tIiwiaWF0IjoxNzA2NDM5MDAwLCJleHAiOjE3MDcwNDM4MDB9.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

### Decoded Payload Example

```json
{
  "user_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "email": "user@example.com",
  "iat": 1706439000,
  "exp": 1707043800,
  "sub": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}
```

### Signature Algorithm

- **Algorithm**: HS256 (HMAC with SHA-256)
- **Secret Key**: `BETTER_AUTH_SECRET` environment variable (shared between frontend and backend)
- **Key Length**: Minimum 32 characters (256 bits) recommended

### Token Lifecycle

```
1. User Login → Better Auth generates JWT with 7-day expiration
2. Token Stored → Client stores in HTTP-only cookie (or localStorage)
3. API Request → Client sends token in Authorization header
4. Token Verification → Backend verifies signature and expiration
5. Token Expiration → After 7 days, token becomes invalid
6. User Logout → Token removed from client storage (server doesn't track)
```

### Validation Rules

- **Signature**: MUST match expected signature using `BETTER_AUTH_SECRET`
- **Expiration**: Current time MUST be before `exp` timestamp
- **Required Claims**: MUST include `user_id`, `email`, `iat`, `exp`
- **Issuer**: (Optional) Can add `iss` claim for additional validation

### Security Properties

| Property | Implementation | Purpose |
|----------|----------------|---------|
| **Stateless** | No server-side session storage | Enables horizontal scaling |
| **Tamper-Proof** | Cryptographic signature | Prevents token modification |
| **Time-Limited** | 7-day expiration | Limits exposure window |
| **User-Bound** | Includes user_id claim | Enables data isolation |

### Token Verification (Backend)

```python
# middleware/jwt_middleware.py
import jwt
import os
from fastapi import HTTPException

def verify_jwt_token(token: str) -> dict:
    """
    Verify JWT token signature and extract payload.

    Args:
        token: JWT token string

    Returns:
        dict: Decoded token payload with user_id and email

    Raises:
        HTTPException: 401 if token is invalid or expired
    """
    try:
        payload = jwt.decode(
            token,
            os.getenv("BETTER_AUTH_SECRET"),
            algorithms=["HS256"]
        )
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="Token expired. Please log in again"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401,
            detail="Invalid authentication token"
        )
```

---

## Data Flow Diagrams

### User Registration Flow

```
1. User submits signup form (email + password)
   └─> Frontend validates email format and password length
2. Frontend sends POST /api/auth/signup
   └─> Better Auth hashes password with bcrypt
   └─> Better Auth inserts record into users table
3. Backend returns User object (without password_hash)
   └─> Frontend redirects to login page
```

### User Login Flow

```
1. User submits login form (email + password)
   └─> Frontend sends POST /api/auth/login
2. Better Auth verifies password hash
   └─> If valid: Generate JWT token with user_id, email, 7-day expiration
   └─> If invalid: Return 401 error
3. Frontend stores JWT in HTTP-only cookie
   └─> Frontend redirects to dashboard
```

### Authenticated API Request Flow

```
1. User makes API request (e.g., GET /api/tasks)
   └─> Browser automatically attaches JWT cookie
2. FastAPI middleware extracts token from Authorization header
   └─> Middleware verifies JWT signature
   └─> Middleware decodes payload to extract user_id
   └─> Middleware injects user_id into request.state
3. Route handler uses request.state.user_id to filter database query
   └─> SQLModel query: SELECT * FROM tasks WHERE user_id = <user_id>
4. Backend returns user-specific data only
```

---

## Database Schema (Neon PostgreSQL)

### CREATE TABLE Statement

```sql
-- Users table (managed by Better Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Future: Tasks table will reference users.id
-- CREATE TABLE tasks (
--     id SERIAL PRIMARY KEY,
--     user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
--     ...
-- );
```

### Migration Strategy

1. **Initial Migration**: Better Auth creates `users` table on first run
2. **Schema Validation**: SQLModel validates table structure matches model definitions
3. **Future Migrations**: Use Alembic for schema changes (if needed beyond Better Auth defaults)

---

## Summary

### Key Entities

1. **User** (Database)
   - Persistent storage in Neon PostgreSQL
   - Managed by Better Auth
   - Indexed by email for fast lookups
   - Relationships to tasks (defined in task CRUD feature)

2. **JWT Token** (Ephemeral)
   - Client-side storage only
   - 7-day expiration
   - Cryptographically signed with shared secret
   - Contains user_id for data isolation

### Data Isolation Strategy

All database queries MUST filter by `user_id` extracted from JWT token:
```python
# Example: Get user's tasks
tasks = session.exec(
    select(Task).where(Task.user_id == request.state.user_id)
).all()
```

### Security Considerations

- ✅ Passwords hashed with bcrypt (never stored in plain text)
- ✅ JWT tokens signed with shared secret (tamper-proof)
- ✅ Tokens expire after 7 days (limited exposure window)
- ✅ User data isolated by user_id filtering (no cross-user access)
- ✅ Email uniqueness enforced at database level

---

**Data Model Status**: ✅ COMPLETE - Ready for contract definition and implementation
